//! Alert rule management and configuration
//!
//! This module provides alert rule definitions, metadata management,
//! dependencies, templates, and rule lifecycle management.

use super::types_config::{AlertSeverity, AlertThreshold, EvaluationQoS};
use super::evaluation_engine::AlertEvaluation;

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::{Duration, SystemTime};

/// Configuration for alert rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRule {
    /// Unique identifier for the rule
    pub rule_id: String,
    /// Human-readable name
    pub name: String,
    /// Description of what triggers this alert
    pub description: String,
    /// Alert expression/query
    pub expression: String,
    /// Duration for which condition must be true
    pub duration: Duration,
    /// Alert severity level
    pub severity: AlertSeverity,
    /// Labels attached to the alert
    pub labels: HashMap<String, String>,
    /// Annotations for the alert
    pub annotations: HashMap<String, String>,
    /// Whether the rule is enabled
    pub enabled: bool,
    /// Threshold configuration
    pub threshold: AlertThreshold,
    /// Evaluation configuration
    pub evaluation: AlertEvaluation,
    /// Rule metadata for tracking
    pub metadata: AlertRuleMetadata,
    /// Rule dependencies
    pub dependencies: Vec<AlertRuleDependency>,
    /// Template information if rule was created from template
    pub template_info: Option<RuleTemplateInfo>,
}

impl Default for AlertRule {
    fn default() -> Self {
        Self {
            rule_id: String::new(),
            name: String::new(),
            description: String::new(),
            expression: String::new(),
            duration: Duration::from_secs(300),
            severity: AlertSeverity::Medium,
            labels: HashMap::new(),
            annotations: HashMap::new(),
            enabled: true,
            threshold: AlertThreshold::default(),
            evaluation: AlertEvaluation::default(),
            metadata: AlertRuleMetadata::default(),
            dependencies: Vec::new(),
            template_info: None,
        }
    }
}

/// Rule metadata for tracking and management
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRuleMetadata {
    /// Timestamp when rule was created
    pub created_at: SystemTime,
    /// Timestamp when rule was last modified
    pub modified_at: SystemTime,
    /// User who created the rule
    pub created_by: String,
    /// User who last modified the rule
    pub modified_by: String,
    /// Rule version number
    pub version: u32,
    /// Source of the rule
    pub source: RuleSource,
    /// Tags for categorization
    pub tags: Vec<String>,
    /// Current lifecycle stage
    pub lifecycle_stage: RuleLifecycleStage,
}

impl Default for AlertRuleMetadata {
    fn default() -> Self {
        Self {
            created_at: SystemTime::now(),
            modified_at: SystemTime::now(),
            created_by: "system".to_string(),
            modified_by: "system".to_string(),
            version: 1,
            source: RuleSource::Manual,
            tags: Vec::new(),
            lifecycle_stage: RuleLifecycleStage::Development,
        }
    }
}

/// Source of alert rule creation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleSource {
    /// Manually created rule
    Manual,
    /// Generated from template
    Template { template_id: String },
    /// Imported from external system
    Imported { source_system: String },
    /// Generated by machine learning
    MachineLearning { model_id: String },
    /// Generated by anomaly detection
    AnomalyDetection { detector_id: String },
    /// Cloned from existing rule
    Cloned { original_rule_id: String },
}

/// Lifecycle stages of alert rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleLifecycleStage {
    /// Rule is in development/testing
    Development,
    /// Rule is in staging environment
    Staging,
    /// Rule is active in production
    Production,
    /// Rule is deprecated but still active
    Deprecated,
    /// Rule is disabled/archived
    Archived,
    /// Rule is scheduled for deletion
    PendingDeletion,
}

/// Alert rule dependency
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRuleDependency {
    /// ID of the dependent rule
    pub dependent_rule_id: String,
    /// Type of dependency
    pub dependency_type: DependencyType,
    /// Condition for the dependency
    pub condition: DependencyCondition,
    /// Whether this is a hard or soft dependency
    pub is_hard_dependency: bool,
}

/// Types of rule dependencies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DependencyType {
    /// Rule must fire before this rule
    Prerequisite,
    /// Rule must not fire for this rule to fire
    Inhibitor,
    /// Rules are mutually exclusive
    MutuallyExclusive,
    /// Rule enhances this rule's context
    Contextual,
    /// Rule provides escalation path
    Escalation,
}

/// Dependency condition evaluation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DependencyCondition {
    /// Dependent rule is currently firing
    Firing,
    /// Dependent rule fired within time window
    FiredWithin(Duration),
    /// Dependent rule is acknowledged
    Acknowledged,
    /// Dependent rule is resolved
    Resolved,
    /// Custom condition expression
    Custom(String),
}

/// Rule template information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleTemplateInfo {
    /// ID of the template used
    pub template_id: String,
    /// Version of the template
    pub template_version: String,
    /// Parameters used to instantiate the template
    pub template_parameters: HashMap<String, String>,
    /// Timestamp when rule was created from template
    pub instantiated_at: SystemTime,
    /// Whether rule allows template updates
    pub auto_update_enabled: bool,
}

/// Alert rule template for creating standardized rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRuleTemplate {
    /// Unique template identifier
    pub template_id: String,
    /// Template name
    pub name: String,
    /// Template description
    pub description: String,
    /// Template version
    pub version: String,
    /// Template categories/tags
    pub categories: Vec<String>,
    /// Template parameters
    pub parameters: Vec<TemplateParameter>,
    /// Template rule definition
    pub rule_template: AlertRuleTemplateDefinition,
    /// Template metadata
    pub metadata: TemplateMetadata,
}

/// Template parameter definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateParameter {
    /// Parameter name
    pub name: String,
    /// Parameter description
    pub description: String,
    /// Parameter type
    pub parameter_type: ParameterType,
    /// Default value
    pub default_value: Option<String>,
    /// Whether parameter is required
    pub required: bool,
    /// Validation rules
    pub validation_rules: Vec<ValidationRule>,
}

/// Parameter types for templates
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ParameterType {
    String,
    Number,
    Boolean,
    Duration,
    List { item_type: Box<ParameterType> },
    Object { schema: HashMap<String, ParameterType> },
}

/// Validation rules for template parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationRule {
    MinLength(usize),
    MaxLength(usize),
    MinValue(f64),
    MaxValue(f64),
    Regex(String),
    OneOf(Vec<String>),
    Custom(String),
}

/// Template rule definition with placeholders
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRuleTemplateDefinition {
    /// Rule name template
    pub name_template: String,
    /// Description template
    pub description_template: String,
    /// Expression template
    pub expression_template: String,
    /// Default severity
    pub default_severity: AlertSeverity,
    /// Default duration
    pub default_duration: Duration,
    /// Default labels
    pub default_labels: HashMap<String, String>,
    /// Default annotations
    pub default_annotations: HashMap<String, String>,
    /// Default threshold configuration
    pub default_threshold: AlertThreshold,
    /// Default evaluation configuration
    pub default_evaluation: AlertEvaluation,
}

/// Template metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateMetadata {
    /// Template author
    pub author: String,
    /// Creation timestamp
    pub created_at: SystemTime,
    /// Last modified timestamp
    pub modified_at: SystemTime,
    /// Template usage count
    pub usage_count: usize,
    /// Template rating
    pub rating: Option<f64>,
    /// Documentation URL
    pub documentation_url: Option<String>,
}

/// Rule validation result
#[derive(Debug, Clone)]
pub struct RuleValidationResult {
    /// Whether the rule is valid
    pub is_valid: bool,
    /// Validation errors
    pub errors: Vec<String>,
    /// Validation warnings
    pub warnings: Vec<String>,
    /// Validation suggestions
    pub suggestions: Vec<String>,
}

/// Rule performance metrics
#[derive(Debug, Clone)]
pub struct RulePerformanceMetrics {
    /// Number of times rule has fired
    pub fire_count: u64,
    /// Average evaluation time
    pub average_evaluation_time: Duration,
    /// Last evaluation time
    pub last_evaluation_time: SystemTime,
    /// Success rate of evaluations
    pub evaluation_success_rate: f64,
    /// False positive rate
    pub false_positive_rate: f64,
    /// Alert resolution statistics
    pub resolution_stats: RuleResolutionStats,
}

/// Alert resolution statistics for a rule
#[derive(Debug, Clone)]
pub struct RuleResolutionStats {
    /// Average time to acknowledgment
    pub average_ack_time: Duration,
    /// Average time to resolution
    pub average_resolution_time: Duration,
    /// Percentage of alerts that were acknowledged
    pub acknowledgment_rate: f64,
    /// Percentage of alerts that were auto-resolved
    pub auto_resolution_rate: f64,
}

impl AlertRule {
    /// Create a new alert rule with minimal configuration
    pub fn new(rule_id: String, name: String, expression: String, severity: AlertSeverity) -> Self {
        Self {
            rule_id,
            name,
            expression,
            severity,
            ..Default::default()
        }
    }

    /// Validate the alert rule configuration
    pub fn validate(&self) -> RuleValidationResult {
        let mut errors = Vec::new();
        let mut warnings = Vec::new();
        let mut suggestions = Vec::new();

        // Basic validation
        if self.rule_id.is_empty() {
            errors.push("Rule ID cannot be empty".to_string());
        }

        if self.name.is_empty() {
            errors.push("Rule name cannot be empty".to_string());
        }

        if self.expression.is_empty() {
            errors.push("Rule expression cannot be empty".to_string());
        }

        // Duration validation
        if self.duration < Duration::from_secs(1) {
            warnings.push("Very short duration may cause alert flapping".to_string());
        }

        if self.duration > Duration::from_secs(3600) {
            warnings.push("Long duration may delay important alerts".to_string());
        }

        // Suggestions
        if self.labels.is_empty() {
            suggestions.push("Consider adding labels for better alert routing".to_string());
        }

        if self.dependencies.is_empty() && matches!(self.severity, AlertSeverity::Critical | AlertSeverity::High) {
            suggestions.push("High severity alerts might benefit from dependency rules".to_string());
        }

        RuleValidationResult {
            is_valid: errors.is_empty(),
            errors,
            warnings,
            suggestions,
        }
    }

    /// Clone rule with new ID and metadata
    pub fn clone_with_new_id(&self, new_rule_id: String, created_by: String) -> Self {
        let mut cloned = self.clone();
        cloned.rule_id = new_rule_id;
        cloned.metadata.created_by = created_by.clone();
        cloned.metadata.modified_by = created_by;
        cloned.metadata.created_at = SystemTime::now();
        cloned.metadata.modified_at = SystemTime::now();
        cloned.metadata.version = 1;
        cloned.metadata.source = RuleSource::Cloned {
            original_rule_id: self.rule_id.clone()
        };
        cloned
    }

    /// Update rule from template
    pub fn update_from_template(&mut self, template: &AlertRuleTemplate, parameters: HashMap<String, String>) -> Result<(), String> {
        // Apply template updates while preserving custom modifications
        // This would contain template expansion logic

        self.template_info = Some(RuleTemplateInfo {
            template_id: template.template_id.clone(),
            template_version: template.version.clone(),
            template_parameters: parameters,
            instantiated_at: SystemTime::now(),
            auto_update_enabled: true,
        });

        self.metadata.modified_at = SystemTime::now();
        self.metadata.version += 1;

        Ok(())
    }

    /// Check if rule is enabled and in active lifecycle stage
    pub fn is_active(&self) -> bool {
        self.enabled && matches!(
            self.metadata.lifecycle_stage,
            RuleLifecycleStage::Production | RuleLifecycleStage::Staging
        )
    }

    /// Get rule age
    pub fn get_age(&self) -> Duration {
        SystemTime::now()
            .duration_since(self.metadata.created_at)
            .unwrap_or(Duration::from_secs(0))
    }
}

impl AlertRuleTemplate {
    /// Create a new template
    pub fn new(template_id: String, name: String, version: String) -> Self {
        Self {
            template_id,
            name,
            version,
            description: String::new(),
            categories: Vec::new(),
            parameters: Vec::new(),
            rule_template: AlertRuleTemplateDefinition {
                name_template: String::new(),
                description_template: String::new(),
                expression_template: String::new(),
                default_severity: AlertSeverity::Medium,
                default_duration: Duration::from_secs(300),
                default_labels: HashMap::new(),
                default_annotations: HashMap::new(),
                default_threshold: AlertThreshold::default(),
                default_evaluation: AlertEvaluation::default(),
            },
            metadata: TemplateMetadata {
                author: "system".to_string(),
                created_at: SystemTime::now(),
                modified_at: SystemTime::now(),
                usage_count: 0,
                rating: None,
                documentation_url: None,
            },
        }
    }

    /// Instantiate a rule from this template
    pub fn instantiate(&self, rule_id: String, parameters: HashMap<String, String>) -> Result<AlertRule, String> {
        // Validate parameters
        for param in &self.parameters {
            if param.required && !parameters.contains_key(&param.name) {
                return Err(format!("Required parameter '{}' is missing", param.name));
            }
        }

        // Expand templates with parameters
        let name = self.expand_template(&self.rule_template.name_template, &parameters);
        let description = self.expand_template(&self.rule_template.description_template, &parameters);
        let expression = self.expand_template(&self.rule_template.expression_template, &parameters);

        Ok(AlertRule {
            rule_id,
            name,
            description,
            expression,
            duration: self.rule_template.default_duration,
            severity: self.rule_template.default_severity.clone(),
            labels: self.rule_template.default_labels.clone(),
            annotations: self.rule_template.default_annotations.clone(),
            enabled: true,
            threshold: self.rule_template.default_threshold.clone(),
            evaluation: self.rule_template.default_evaluation.clone(),
            metadata: AlertRuleMetadata {
                source: RuleSource::Template { template_id: self.template_id.clone() },
                ..AlertRuleMetadata::default()
            },
            dependencies: Vec::new(),
            template_info: Some(RuleTemplateInfo {
                template_id: self.template_id.clone(),
                template_version: self.version.clone(),
                template_parameters: parameters,
                instantiated_at: SystemTime::now(),
                auto_update_enabled: true,
            }),
        })
    }

    /// Expand template string with parameters
    fn expand_template(&self, template: &str, parameters: &HashMap<String, String>) -> String {
        let mut result = template.to_string();

        for (key, value) in parameters {
            let placeholder = format!("{{{}}}", key);
            result = result.replace(&placeholder, value);
        }

        result
    }
}

#[allow(non_snake_case)]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_alert_rule_creation() {
        let rule = AlertRule::new(
            "test_rule".to_string(),
            "Test Rule".to_string(),
            "cpu_usage > 80".to_string(),
            AlertSeverity::Warning
        );

        assert_eq!(rule.rule_id, "test_rule");
        assert_eq!(rule.severity, AlertSeverity::Warning);
        assert!(rule.enabled);
    }

    #[test]
    fn test_rule_validation() {
        let rule = AlertRule::default();
        let validation = rule.validate();

        assert!(!validation.is_valid);
        assert!(validation.errors.len() > 0);
    }

    #[test]
    fn test_valid_rule_validation() {
        let rule = AlertRule::new(
            "valid_rule".to_string(),
            "Valid Rule".to_string(),
            "metric > threshold".to_string(),
            AlertSeverity::Medium
        );

        let validation = rule.validate();
        assert!(validation.is_valid);
    }

    #[test]
    fn test_rule_cloning() {
        let original = AlertRule::new(
            "original".to_string(),
            "Original Rule".to_string(),
            "test_expression".to_string(),
            AlertSeverity::High
        );

        let cloned = original.clone_with_new_id("cloned".to_string(), "test_user".to_string());

        assert_eq!(cloned.rule_id, "cloned");
        assert_eq!(cloned.metadata.created_by, "test_user");
        assert_ne!(cloned.metadata.created_at, original.metadata.created_at);
    }

    #[test]
    fn test_rule_is_active() {
        let mut rule = AlertRule::default();

        // Disabled rule
        rule.enabled = false;
        assert!(!rule.is_active());

        // Enabled but archived
        rule.enabled = true;
        rule.metadata.lifecycle_stage = RuleLifecycleStage::Archived;
        assert!(!rule.is_active());

        // Enabled and in production
        rule.metadata.lifecycle_stage = RuleLifecycleStage::Production;
        assert!(rule.is_active());
    }

    #[test]
    fn test_template_creation() {
        let template = AlertRuleTemplate::new(
            "cpu_template".to_string(),
            "CPU Alert Template".to_string(),
            "1.0".to_string()
        );

        assert_eq!(template.template_id, "cpu_template");
        assert_eq!(template.version, "1.0");
    }

    #[test]
    fn test_template_instantiation() {
        let mut template = AlertRuleTemplate::new(
            "test_template".to_string(),
            "Test Template".to_string(),
            "1.0".to_string()
        );

        template.rule_template.name_template = "Alert for {service}".to_string();
        template.rule_template.expression_template = "{metric} > {threshold}".to_string();

        let mut parameters = HashMap::new();
        parameters.insert("service".to_string(), "web-server".to_string());
        parameters.insert("metric".to_string(), "cpu_usage".to_string());
        parameters.insert("threshold".to_string(), "80".to_string());

        let rule = template.instantiate("instantiated_rule".to_string(), parameters).unwrap();

        assert_eq!(rule.name, "Alert for web-server");
        assert_eq!(rule.expression, "cpu_usage > 80");
    }

    #[test]
    fn test_dependency_types() {
        let dependency = AlertRuleDependency {
            dependent_rule_id: "prereq_rule".to_string(),
            dependency_type: DependencyType::Prerequisite,
            condition: DependencyCondition::Firing,
            is_hard_dependency: true,
        };

        assert_eq!(dependency.dependent_rule_id, "prereq_rule");
        assert!(dependency.is_hard_dependency);
    }

    #[test]
    fn test_rule_metadata_default() {
        let metadata = AlertRuleMetadata::default();
        assert_eq!(metadata.version, 1);
        assert_eq!(metadata.created_by, "system");
        assert!(matches!(metadata.source, RuleSource::Manual));
    }
}